<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>js模块化</title>
      <link href="/2022/08/15/js%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2022/08/15/js%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一个模块就是一个文件，模块可以相互加载，并可以使用特殊的指令 export 和 import 来交换功能，从另一个模块调用一个模块的函数<br>export 关键字标记了可以从当前模块外部访问的变量和函数。<br>import 关键字允许从其他模块导入功能。<br>例如，我们有一个 sayHi.js 文件导出了一个函数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 📁 sayHi.js</span><br><span class="line">export function sayHi(user) &#123;</span><br><span class="line">  alert(`Hello, $&#123;user&#125;!`);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>……然后另一个文件可能导入并使用了这个函数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 📁 main.js</span><br><span class="line">import &#123; sayHi &#125; from &#x27;./sayHi.js&#x27;;</span><br><span class="line"></span><br><span class="line">alert(sayHi); // function...</span><br><span class="line">sayHi(&#x27;John&#x27;); // Hello, John!</span><br></pre></td></tr></table></figure><p>import 指令通过相对于当前文件的路径 ./sayHi.js 加载模块，并将导入的函数 sayHi 分配（assign）给相应的变量。</p><p>让我们在浏览器中运行一下这个示例。</p><p>由于模块支持特殊的关键字和功能，因此我们必须通过使用 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt; 特性（attribute）来告诉浏览器，此脚本应该被当作模块（module）来对待。 </span><br></pre></td></tr></table></figure><p>像这样：<br>index.html</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">  import &#123;sayHi&#125; from &#x27;./say.js&#x27;;</span><br><span class="line"></span><br><span class="line">  document.body.innerHTML = sayHi(&#x27;John&#x27;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>say.js</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export function sayHi(user) &#123;</span><br><span class="line">  return `Hello, $&#123;user&#125;!`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器会自动获取并解析（evaluate）导入的模块（如果需要，还可以分析该模块的导入），然后运行该脚本。<br>模块只通过 HTTP(s) 工作，而非本地<br>如果你尝试通过 file:// 协议在本地打开一个网页，你会发现 import/export 指令不起作用。你可以使用本地 Web 服务器，例如 static-server，或者使用编辑器的“实时服务器”功能，例如 VS Code 的 Live Server Extension 来测试模块。</p><h1 id="导出的语法示例-声明前导出"><a href="#导出的语法示例-声明前导出" class="headerlink" title="导出的语法示例-声明前导出"></a>导出的语法示例-声明前导出</h1><p>我们可以通过在声明之前放置 export 来标记任意声明为导出，无论声明的是变量，函数还是类都可以。</p><p>例如，这里的所有导出均有效：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 导出数组</span><br><span class="line">export let months = [&#x27;Jan&#x27;, &#x27;Feb&#x27;, &#x27;Mar&#x27;,&#x27;Apr&#x27;, &#x27;Aug&#x27;, &#x27;Sep&#x27;, &#x27;Oct&#x27;, &#x27;Nov&#x27;, &#x27;Dec&#x27;];</span><br><span class="line"></span><br><span class="line">// 导出 const 声明的变量</span><br><span class="line">export const MODULES_BECAME_STANDARD_YEAR = 2015;</span><br><span class="line"></span><br><span class="line">// 导出类</span><br><span class="line">export class User &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导出 class/function 后没有分号<br>注意，在类或者函数前的 export 不会让它们变成 函数表达式。尽管被导出了，但它仍然是一个函数声明。</p><p>大部分 JavaScript 样式指南都不建议在函数和类声明后使用分号。</p><p>这就是为什么在 export class 和 export function 的末尾不需要加分号：</p><h1 id="导出的语法示例-导出与声明分开"><a href="#导出的语法示例-导出与声明分开" class="headerlink" title="导出的语法示例-导出与声明分开"></a>导出的语法示例-导出与声明分开</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 📁 say.js</span><br><span class="line">function sayHi(user) &#123;</span><br><span class="line">  alert(`Hello, $&#123;user&#125;!`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sayBye(user) &#123;</span><br><span class="line">  alert(`Bye, $&#123;user&#125;!`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123;sayHi, sayBye&#125;; // 导出变量列表</span><br></pre></td></tr></table></figure><p>……从技术上讲，我们也可以把 export 放在函数上面。</p><h1 id="import的使用"><a href="#import的使用" class="headerlink" title="import的使用"></a>import的使用</h1><p>通常，我们把要导入的东西列在花括号 import {…} 中，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 📁 main.js</span><br><span class="line">import &#123;sayHi, sayBye&#125; from &#x27;./say.js&#x27;;</span><br><span class="line"></span><br><span class="line">sayHi(&#x27;John&#x27;); // Hello, John!</span><br><span class="line">sayBye(&#x27;John&#x27;); // Bye, John!</span><br></pre></td></tr></table></figure><p>但是如果有很多要导入的内容，我们可以使用 import * as <obj> 将所有内容导入为一个对象，例如：</obj></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 📁 main.js</span><br><span class="line">import * as say from &#x27;./say.js&#x27;;</span><br><span class="line"></span><br><span class="line">say.sayHi(&#x27;John&#x27;);</span><br><span class="line">say.sayBye(&#x27;John&#x27;);</span><br></pre></td></tr></table></figure><p>我们也可以使用 as 让导入具有不同的名字。</p><p>例如，简洁起见，我们将 sayHi 导入到局部变量 hi，将 sayBye 导入到 bye：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 📁 main.js</span><br><span class="line">import &#123;sayHi as hi, sayBye as bye&#125; from &#x27;./say.js&#x27;;</span><br><span class="line"></span><br><span class="line">hi(&#x27;John&#x27;); // Hello, John!</span><br><span class="line">bye(&#x27;John&#x27;); // Bye, John!</span><br></pre></td></tr></table></figure><p>导出也具有类似的语法。</p><p>我们将函数导出为 hi 和 bye：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 📁 say.js</span><br><span class="line">...</span><br><span class="line">export &#123;sayHi as hi, sayBye as bye&#125;</span><br></pre></td></tr></table></figure><h1 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h1><p>在实际中，主要有两种模块。</p><p>包含库或函数包的模块，像上面的 say.js。<br>声明单个实体的模块，例如模块 user.js 仅导出 class User。<br>大部分情况下，开发者倾向于使用第二种方式，以便每个“东西”都存在于它自己的模块中。</p><p>当然，这需要大量文件，因为每个东西都需要自己的模块，但这根本不是问题。实际上，如果文件具有良好的命名，并且文件夹结构得当，那么代码导航（navigation）会变得更容易。</p><p>模块提供了一个特殊的默认导出 export default 语法，以使“一个模块只做一件事”的方式看起来更好。</p><p>将 export default 放在要导出的实体前：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 📁 user.js</span><br><span class="line">export default class User &#123; // 只需要添加 &quot;default&quot; 即可</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个文件应该只有一个 export default：</p><p>……然后将其导入而不需要花括号：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 📁 main.js</span><br><span class="line">import User from &#x27;./user.js&#x27;; // 不需要花括号 &#123;User&#125;，只需要写成 User 即可</span><br><span class="line"></span><br><span class="line">new User(&#x27;John&#x27;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js数组方法汇总</title>
      <link href="/2022/08/12/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/"/>
      <url>/2022/08/12/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p>既然是数组，是一种数据类型，必然是增删查改<br>让我们一起来了解这种数据类型的一些常用的方法吧</p><h1 id="头尾增删"><a href="#头尾增删" class="headerlink" title="头尾增删"></a>头尾增删</h1><p>arr.push(…items)– 将项目添加到末尾，<br>arr.pop()– 从末尾提取一个项目，<br>arr.shift()– 从头提取一个项目，<br>arr.unshift(…items)- 将项目添加到开头</p><h1 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h1><p>arr.splice方法是数组的瑞士军刀。它可以做任何事情：插入、删除和替换元素<br>arr.splice(start, deleteCount, elem1, …, elemN)<br>第一个参数：start:开始删除的索引<br>第二个参数：deleteCount：删除的个数<br>后面的参数：替换的元素<br>一起来看几个例子吧</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [&quot;I&quot;, &quot;go&quot;, &quot;home&quot;];</span><br><span class="line"></span><br><span class="line">delete arr[1]; // remove &quot;go&quot;</span><br><span class="line"></span><br><span class="line">alert( arr[1] ); // undefined</span><br><span class="line"></span><br><span class="line">// now arr = [&quot;I&quot;,  , &quot;home&quot;];</span><br><span class="line">alert( arr.length ); // 3</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [&quot;I&quot;, &quot;study&quot;, &quot;JavaScript&quot;];</span><br><span class="line"></span><br><span class="line">arr.splice(1, 1); // from index 1 remove 1 element</span><br><span class="line"></span><br><span class="line">alert( arr ); // [&quot;I&quot;, &quot;JavaScript&quot;]</span><br></pre></td></tr></table></figure><p>替换<br>在下一个示例中，我们删除 3 个元素并用另外两个替换它们：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [&quot;I&quot;, &quot;study&quot;, &quot;JavaScript&quot;, &quot;right&quot;, &quot;now&quot;];</span><br><span class="line"></span><br><span class="line">// remove 3 first elements and replace them with another</span><br><span class="line">arr.splice(0, 3, &quot;Let&#x27;s&quot;, &quot;dance&quot;);</span><br><span class="line"></span><br><span class="line">alert( arr ) // now [&quot;Let&#x27;s&quot;, &quot;dance&quot;, &quot;right&quot;, &quot;now&quot;]</span><br></pre></td></tr></table></figure><p>在这里和其他数组方法中，允许使用负索引。它们指定从数组末尾开始的位置，如下所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 5];</span><br><span class="line"></span><br><span class="line">// from index -1 (one step from the end)</span><br><span class="line">// delete 0 elements,</span><br><span class="line">// then insert 3 and 4</span><br><span class="line">arr.splice(-1, 0, 3, 4);</span><br><span class="line"></span><br><span class="line">alert( arr ); // 1,2,3,4,5</span><br></pre></td></tr></table></figure><h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h1><p>arr.slice(start, end)<br>它返回一个新数组，将所有项目从索引复制到start（end不包括end）。两者start和end都可以是负数，在这种情况下，假设从数组末端开始。</p><p>它类似于字符串方法str.slice，但它不是子字符串，而是子数组。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [&quot;t&quot;, &quot;e&quot;, &quot;s&quot;, &quot;t&quot;];</span><br><span class="line"></span><br><span class="line">alert( arr.slice(1, 3) ); // e,s (copy from 1 to 3)</span><br><span class="line"></span><br><span class="line">alert( arr.slice(-2) ); // s,t (copy from -2 till the end)</span><br></pre></td></tr></table></figure><h1 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h1><p>方法arr.concat创建一个新数组，其中包括来自其他数组的值和其他项。</p><p>语法是：</p><p>arr.concat(arg1, arg2…)<br>它接受任意数量的参数——数组或值。</p><p>结果是一个新数组，其中包含来自arr、 thenarg1等的项目arg2。</p><p>如果参数argN是数组，则复制其所有元素。否则，将复制参数本身。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2];</span><br><span class="line"></span><br><span class="line">// create an array from: arr and [3,4]</span><br><span class="line">alert( arr.concat([3, 4]) ); // 1,2,3,4</span><br><span class="line"></span><br><span class="line">// create an array from: arr and [3,4] and [5,6]</span><br><span class="line">alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6</span><br><span class="line"></span><br><span class="line">// create an array from: arr and [3,4], then add values 5 and 6</span><br><span class="line">alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6</span><br></pre></td></tr></table></figure><h1 id="在数组中搜索indexOf-lastIndexOf-and-includes"><a href="#在数组中搜索indexOf-lastIndexOf-and-includes" class="headerlink" title="在数组中搜索indexOf/lastIndexOf and includes"></a>在数组中搜索indexOf/lastIndexOf and includes</h1><p>方法arr.indexOf和arr.includes具有相似的语法，并且与它们的字符串对应物基本相同，但对项目而不是字符进行操作：</p><p>arr.indexOf(item, from)–item从 index 开始查找from，并返回找到它的索引，否则返回-1。<br>arr.includes(item, from)–item从 index 开始查找，如果找到则from返回。true<br>通常这些方法只与一个参数一起使用：item搜索。默认情况下，搜索是从头开始的。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [1, 0, false];</span><br><span class="line"></span><br><span class="line">alert( arr.indexOf(0) ); // 1</span><br><span class="line">alert( arr.indexOf(false) ); // 2</span><br><span class="line">alert( arr.indexOf(null) ); // -1</span><br><span class="line"></span><br><span class="line">alert( arr.includes(1) ); // true</span><br></pre></td></tr></table></figure><p>请注意，indexOf使用严格相等===进行比较。因此，如果我们寻找false，它会准确找到false而不是零。</p><p>如果我们想检查item数组中是否存在，并且不需要确切的索引，那么arr.includes首选。</p><p>方法arr.lastIndexOf与 相同indexOf，但从右到左查找。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let fruits = [&#x27;Apple&#x27;, &#x27;Orange&#x27;, &#x27;Apple&#x27;]</span><br><span class="line"></span><br><span class="line">alert( arr.indexOf(&#x27;Apple&#x27;) ); // 0 (first Apple)</span><br><span class="line">alert( arr.lastIndexOf(&#x27;Apple&#x27;) ); // 2 (last Apple)</span><br></pre></td></tr></table></figure><h1 id="find-and-findIndex-findLastIndex"><a href="#find-and-findIndex-findLastIndex" class="headerlink" title="find and findIndex/findLastIndex"></a>find and findIndex/findLastIndex</h1><p>想象一下，我们有一个对象数组。我们如何找到具有特定条件的对象？</p><p>这里arr.find(fn)方法就派上用场了。</p><p>语法是：</p><p>let result = arr.find(function(item, index, array) {<br>  // if true is returned, item is returned and iteration is stopped<br>  // for falsy scenario returns undefined<br>});<br>该函数被一个接一个地调用数组的元素：</p><p>item是元素。<br>index是它的索引。<br>array是数组本身。<br>如果返回true，则停止搜索，item返回 。如果没有找到，undefined则返回。</p><p>例如，我们有一个用户数组，每个用户都有字段id和name。让我们找到一个id == 1：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let users = [</span><br><span class="line">  &#123;id: 1, name: &quot;John&quot;&#125;,</span><br><span class="line">  &#123;id: 2, name: &quot;Pete&quot;&#125;,</span><br><span class="line">  &#123;id: 3, name: &quot;Mary&quot;&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">let user = users.find(item =&gt; item.id == 1);</span><br><span class="line"></span><br><span class="line">alert(user.name); // John</span><br></pre></td></tr></table></figure><p>在现实生活中，对象数组是很常见的事情，因此该find方法非常有用。</p><p>请注意，在示例中，我们为find函数item =&gt; item.id == 1提供了一个参数。这是典型的，这个函数的其他参数很少使用。</p><p>arr.findIndex方法具有相同的语法，但返回找到元素的索引而不是元素本身。-1如果没有找到，则返回 的值。</p><p>arr.findLastIndex方法类似于，findIndex但从右到左搜索，类似于lastIndexOf。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let users = [</span><br><span class="line">  &#123;id: 1, name: &quot;John&quot;&#125;,</span><br><span class="line">  &#123;id: 2, name: &quot;Pete&quot;&#125;,</span><br><span class="line">  &#123;id: 3, name: &quot;Mary&quot;&#125;,</span><br><span class="line">  &#123;id: 4, name: &quot;John&quot;&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// Find the index of the first John</span><br><span class="line">alert(users.findIndex(user =&gt; user.name == &#x27;John&#x27;)); // 0</span><br><span class="line"></span><br><span class="line">// Find the index of the last John</span><br><span class="line">alert(users.findLastIndex(user =&gt; user.name == &#x27;John&#x27;)); // 3</span><br></pre></td></tr></table></figure><p>filter<br>该find方法查找使函数返回的单个（第一个）元素true。</p><p>如果可能有很多，我们可以使用arr.filter(fn)。</p><p>语法类似于find，但filter返回一个包含所有匹配元素的数组：</p><p>let results = arr.filter(function(item, index, array) {<br>  // if true item is pushed to results and the iteration continues<br>  // returns empty array if nothing found<br>});</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let users = [</span><br><span class="line">  &#123;id: 1, name: &quot;John&quot;&#125;,</span><br><span class="line">  &#123;id: 2, name: &quot;Pete&quot;&#125;,</span><br><span class="line">  &#123;id: 3, name: &quot;Mary&quot;&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// returns array of the first two users</span><br><span class="line">let someUsers = users.filter(item =&gt; item.id &lt; 3);</span><br><span class="line"></span><br><span class="line">alert(someUsers.length); // 2</span><br></pre></td></tr></table></figure><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>arr.map方法是最有用和最常用的方法之一。</p><p>它为数组的每个元素调用函数并返回结果数组。</p><p>语法是：let result = arr.map(function(item, index, array) {<br>  // returns the new value instead of item<br>});<br>例如，在这里我们将每个元素转换为它的长度：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let lengths = [&quot;Bilbo&quot;, &quot;Gandalf&quot;, &quot;Nazgul&quot;].map(item =&gt; item.length);</span><br><span class="line">alert(lengths); // 5,7,6</span><br></pre></td></tr></table></figure><h1 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h1><p>对arr.sort()的调用对数组进行就地排序，改变其元素顺序。</p><p>它还返回排序后的数组，但返回的值通常会被忽略，因为arr它本身已被修改。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [ 1, 2, 15 ];</span><br><span class="line"></span><br><span class="line">// the method reorders the content of arr</span><br><span class="line">arr.sort();</span><br><span class="line"></span><br><span class="line">alert( arr );  // 1, 15, 2</span><br></pre></td></tr></table></figure><p>你注意到结果中有什么奇怪的地方吗？</p><p>顺序变成了1, 15, 2。不正确。但为什么？</p><p>默认情况下，项目按字符串排序。</p><p>从字面上看，所有元素都转换为字符串以进行比较。对于字符串，应用了字典顺序，并且确实是”2” &gt; “15”.</p><p>要使用我们自己的排序顺序，我们需要提供一个函数作为arr.sort().</p><p>该函数应该比较两个任意值并返回：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [ 1, 2, 15 ];</span><br><span class="line"></span><br><span class="line">arr.sort(function(a, b) &#123; return a - b; &#125;);</span><br><span class="line"></span><br><span class="line">alert(arr);  // 1, 2, 15</span><br></pre></td></tr></table></figure><p>最佳箭头功能<br>还记得箭头函数吗？我们可以在这里使用它们进行更整洁的排序：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr.sort( (a, b) =&gt; a - b );</span><br></pre></td></tr></table></figure><p>数组对象的话</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var person = [&#123;name:&quot;Rom&quot;,age:12&#125;,&#123;name:&quot;Bob&quot;,age:22&#125;,&#123;name:&quot;Ma&quot;,age:5&#125;,&#123;name:&quot;Tony&quot;,age:25&#125;]</span><br><span class="line"> </span><br><span class="line">person.sort((a,b)=&gt;&#123; return a.age-b.age&#125;)//升序</span><br><span class="line"> </span><br><span class="line">person.sort((a,b)=&gt;&#123; return b.age-a.age&#125;)//降序</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js数组方法汇总 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js数组方法汇总 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eslint</title>
      <link href="/2022/08/10/eslint/"/>
      <url>/2022/08/10/eslint/</url>
      
        <content type="html"><![CDATA[<h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p>我们都知道它们是用来做代码格式化的，但是又分为npm包和vscode插件，到底要怎么使用它们？怎么配置呢？<br>顺序是——先有npm包，再有vscode插件。<br>先从eslint讲起，eslint不仅作代码规范，还有检查变量声明了是否调用，是否有console.log语句等。<br>废话不多说，直接上手来演示一下。</p><h1 id="eslint的npm包"><a href="#eslint的npm包" class="headerlink" title="eslint的npm包"></a>eslint的npm包</h1><p>简单的用法，先npm init -y，初始化包。再建一个index.js文件，写点东西</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//index.js文件</span><br><span class="line"></span><br><span class="line">var a = 1</span><br><span class="line">      let str = &quot;ss&quot;</span><br><span class="line">   console.log(&#x27;111&#x27;);</span><br></pre></td></tr></table></figure><p>然后全局安装eslintnpm i eslint -g（如果之前全局安装过了就不用了），再npx eslint –init，接着会出现几个选择，因为是测试，所以随便选，一直回车就行了。<br>选完之后会自动下载eslint包，并在项目的根目录自动创建.eslintrc.js文件。<br>此时准备工作已经做好了，我们可以开始演示了。先执行eslint index.js<br>这时，终端会报错，说定义了几个变量，但没有使用它们。这就是最基本的用法。<br>但我上面书写的格式风格都不同，eslint并没有检测出来。所以我们要去配置.eslintrc.js文件</p><p>因为里面已经生成好了，所以这里只放出rules部分<br>0是忽略，1是警告，2是报错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//.eslintrc.js</span><br><span class="line"></span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">        &quot;quotes&quot;: 2,</span><br><span class="line">        &quot;semi&quot;: 1,</span><br><span class="line">        &quot;no-console&quot;: 1,</span><br><span class="line">        &quot;space-before-function-paren&quot;: 0</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这时再执行eslint index.js（使用小技巧，在终端里按↑键，就能输出上一次的指令）<br><img src="/2022/08/10/eslint/2022-08-11-10-25-40.png"></p><p>格式的问题也被检测出来了。那么我要怎么修复它们呢？执行eslint index.js –fix<br>这样js文件里面的内容的格式就被修复好了，比如结尾要不要分号，用单引号还是双引号。</p><h1 id="eslint的vscode插件"><a href="#eslint的vscode插件" class="headerlink" title="eslint的vscode插件"></a>eslint的vscode插件</h1><p> 我们每次做项目的时候，都要先eslint . –fix统一格式，再push提交代码。或者是把指令添加到package.json文件中，执行npm run lint，再push。这样就很麻烦，并且也不够直观，因为错误问题只有在你执行了指令之后才能看到。<br>那么我想在我一边写代码的时候就能直接看到错误，然后就能直接随手改正错误，这要怎么做呢？<br>这时eslint的vscode插件诞生了</p>]]></content>
      
      
      <categories>
          
          <category> eslint </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eslint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack</title>
      <link href="/2022/08/10/webpack/"/>
      <url>/2022/08/10/webpack/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack快速上手"><a href="#webpack快速上手" class="headerlink" title="webpack快速上手"></a>webpack快速上手</h1><p>本质上，webpack是一个现代 JavaScript 应用程序的 静态模块打包器(module bundler)<br>首先npm init，创建package.json<br>cnpm install webpack webpack-cli –dev</p><p>在根目录下在创建一个src文件，在此文件中创建header.js 和 index.js<br>header.js</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var elem = document.createElement(&quot;div&quot;);//创建一个节点</span><br><span class="line">elem.innerHTML = &quot;你好，webpack&quot;;//设置内容</span><br><span class="line">export default elem;//导出节点</span><br></pre></td></tr></table></figure><p>index.js</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import elem from &quot;./header.js&quot;;//导入节点</span><br><span class="line">document.body.appendChild(elem);//插入到页面</span><br></pre></td></tr></table></figure><p>在命令提示符输入 npx webpack 进行打包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\myback&gt;npx webpack</span><br><span class="line">//输入完后根目录会生成一个dist文件，文件里会有一个main.js</span><br></pre></td></tr></table></figure><p>在dist文件中新建一个index.html ，在body下方插入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样的话，在浏览器里打开index.html就会看到  你好，webpack  </p><h1 id="使用配置文件"><a href="#使用配置文件" class="headerlink" title="使用配置文件"></a>使用配置文件</h1><p>在项目目录 新建一个  webpack.config.js    webpack默认配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    // 指定文件的入口</span><br><span class="line">    entry: &quot;./src/index.js&quot;,</span><br><span class="line">    //出口</span><br><span class="line">    output: &#123;</span><br><span class="line">        // 定义文件名</span><br><span class="line">        filename: &quot;main.js&quot;,</span><br><span class="line">        // 定义文件夹  // __dirname获取当前目录</span><br><span class="line">        path: __dirname + &quot;dist&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    mode: &quot;production&quot;, //产品模块</span><br><span class="line">&#125;;</span><br><span class="line">// module.export node中导出模块的意思</span><br></pre></td></tr></table></figure><p>执行命令npx webpack实现打包，就不会出现第一次打包的警告了。</p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网</title>
      <link href="/2022/08/03/%E7%89%9B%E5%AE%A2%E7%BD%91/"/>
      <url>/2022/08/03/%E7%89%9B%E5%AE%A2%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<h1 id="1-js牛客网输入输出指南"><a href="#1-js牛客网输入输出指南" class="headerlink" title="1.js牛客网输入输出指南"></a>1.js牛客网输入输出指南</h1><p>1.单行输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var line = readline()</span><br></pre></td></tr></table></figure><p>2.任意多行输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let line</span><br><span class="line">while(line = readline())&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.固定行数多行输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var line_1 = readline();</span><br><span class="line">var line_2 = readline();</span><br><span class="line">var result_1= line_1.split(\&#x27; \&#x27;); //获取第一行的内容，存为数组</span><br><span class="line">var result_2= line_2.split(\&#x27; \&#x27;); //获取第二行的内容，存为数组</span><br><span class="line">print(result_1,result_2);</span><br></pre></td></tr></table></figure><p>4.输出的话，正常console.log</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>12.字符串反转</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let line = readline()</span><br><span class="line">const outstring = line.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)</span><br><span class="line">console.log(outstring)</span><br></pre></td></tr></table></figure><p>54.表达式求值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var line = readline()</span><br><span class="line">console.log(eval(line))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2022/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2022/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2022/07/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2022/07/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="1栈"><a href="#1栈" class="headerlink" title="1栈"></a>1栈</h1><p>栈是一个先进后出的线性数据结构<br>js里面没有这个数据结构,但是我们可以用数组来模拟<br>push：进栈<br>pop：出栈</p><p>我们来看第一次例子<br>leetcode20题 有效的括号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var isValid = function(s) &#123;</span><br><span class="line">    const stack = []</span><br><span class="line">    for(let i = 0;i &lt; s.length;i++)&#123;</span><br><span class="line">        const c = s[i]</span><br><span class="line">        if(c === &#x27;(&#x27; || c === &#x27;&#123;&#x27; || c === &#x27;[&#x27;)&#123;</span><br><span class="line">            stack.push(c)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            const t = stack[stack.length-1]</span><br><span class="line">            if(</span><br><span class="line">                (t === &#x27;(&#x27;&amp;&amp;c === &#x27;)&#x27;)||</span><br><span class="line">                (t === &#x27;[&#x27;&amp;&amp;c === &#x27;]&#x27;)||</span><br><span class="line">                (t === &#x27;&#123;&#x27;&amp;&amp;c === &#x27;&#125;&#x27;)</span><br><span class="line">                )&#123;</span><br><span class="line">                stack.pop()</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return stack.length === 0</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2队列"><a href="#2队列" class="headerlink" title="2队列"></a>2队列</h1><p>队列是一个先进先出的线性数据结构<br>js里面没有这个数据结构,但是我们可以用数组来模拟<br>push：进队列<br>pop：出队列</p><p>我们来看第一次例子<br>leetcode933题 最近的请求次数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var RecentCounter = function() &#123;</span><br><span class="line">    this.q = []</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line"> * @param &#123;number&#125; t</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">RecentCounter.prototype.ping = function(t) &#123;</span><br><span class="line">this.q.push(t)</span><br><span class="line">while(this.q[0]&lt;t-3000)&#123;</span><br><span class="line">    this.q.shift()</span><br><span class="line">&#125;</span><br><span class="line">return this.q.length</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="3链表"><a href="#3链表" class="headerlink" title="3链表"></a>3链表</h1><p>js无链表数据结构，可用对象模拟<br>例子 237单链表删除指定节点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* function ListNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.next = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;ListNode&#125; node</span><br><span class="line"> * @return &#123;void&#125; Do not return anything, modify node in-place instead.</span><br><span class="line"> */</span><br><span class="line">var deleteNode = function(node) &#123;</span><br><span class="line">    node.val = node.next.val</span><br><span class="line">    node.next = node.next.next</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css</title>
      <link href="/2022/07/30/css/"/>
      <url>/2022/07/30/css/</url>
      
        <content type="html"><![CDATA[<h1 id="1元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"><a href="#1元素水平垂直居中的方法有哪些？如果元素不定宽高呢？" class="headerlink" title="1元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"></a>1元素水平垂直居中的方法有哪些？如果元素不定宽高呢？</h1><p>利用定位+margin:auto</p><p>利用定位+margin:负值</p><p>利用定位+transform</p><p>table布局</p><p>flex布局</p><p>grid布局</p><h1 id="2-响应式布局"><a href="#2-响应式布局" class="headerlink" title="2.响应式布局"></a>2.响应式布局</h1>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6</title>
      <link href="/2022/07/30/es6/"/>
      <url>/2022/07/30/es6/</url>
      
        <content type="html"><![CDATA[<h1 id="说说var、let、const之间的区别"><a href="#说说var、let、const之间的区别" class="headerlink" title="说说var、let、const之间的区别"></a>说说var、let、const之间的区别</h1><p>（1）块级作用域：块作用域由 { }包括,let和const具有块级作用域,var不存在块级作用域。</p><p>（2）变量提升：var存在变量提升,let和const不存在变量提升,即在变量只能在声明之后使用,否在会报错。</p><p>（3）重复声明：var声明变量时,可以重复声明变量,后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。</p><p>（4）暂时性死区：在使用let、const命令声明变量之前,该变量都是不可用的。这在语法上,称为暂时性死区。使用var声明的变量不存在暂时性死区。</p><p>（5）初始值设置：在变量声明时,var 和 let 可以不用设置初始值。而const声明变量必须设置初始值</p><h1 id="ES6中数组新增了哪些扩展？"><a href="#ES6中数组新增了哪些扩展？" class="headerlink" title="ES6中数组新增了哪些扩展？"></a>ES6中数组新增了哪些扩展？</h1><h2 id="一、扩展运算符的应用"><a href="#一、扩展运算符的应用" class="headerlink" title="一、扩展运算符的应用"></a>一、扩展运算符的应用</h2><p>ES6通过扩展元素符…，好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(...[1, 2, 3])</span><br><span class="line">// 1 2 3</span><br><span class="line"></span><br><span class="line">console.log(1, ...[2, 3, 4], 5)</span><br><span class="line">// 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(&#x27;div&#x27;)]</span><br></pre></td></tr></table></figure><h2 id="二、实例对象新增的方法"><a href="#二、实例对象新增的方法" class="headerlink" title="二、实例对象新增的方法"></a>二、实例对象新增的方法</h2><p>copyWithin()<br>find()、findIndex()<br>fill()<br>entries()，keys()，values()<br>includes()<br>flat()，flatMap()</p>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue</title>
      <link href="/2022/07/30/vue/"/>
      <url>/2022/07/30/vue/</url>
      
        <content type="html"><![CDATA[<h1 id="1-怎么理解mvvm这种设计模式"><a href="#1-怎么理解mvvm这种设计模式" class="headerlink" title="1.怎么理解mvvm这种设计模式"></a>1.怎么理解mvvm这种设计模式</h1><p> Model–View–ViewModel （MVVM） 是一个软件架构设计模式，是一种简化用户界面的事件驱动编程方式。<br>MVVM<br>   数据驱动视图<br>    M Model 模型 指的是数据层<br>    V View  视图 指的是用户页面<br>    VM ViewModel 视图模型<br>    视图模型是MVVM模式的核心，它是连接view和model的桥梁，MVVM实现了view和model的自动同步，当model的属性改变时，我们不用自己手动操作DOM元素，来改变view的显示，反之亦然，我们称之为数据的双向绑定。</p><h1 id="2-v-if和v-show的区别，使用场景区别"><a href="#2-v-if和v-show的区别，使用场景区别" class="headerlink" title="2.v-if和v-show的区别，使用场景区别"></a>2.v-if和v-show的区别，使用场景区别</h1><p>v-if和v-show看起来似乎差不多，当条件不成立时，其所对应的标签元素都不可见，但是这两个选项是有区别的:<br>1、v-if在条件切换时，会对标签进行适当的创建和销毁，而v-show则仅在初始化时加载一次，因此v-if的开销相对来说会比v-show大。<br>2、v-if是惰性的，只有当条件为真时才会真正渲染标签；如果初始条件不为真，则v-if不会去渲染标签。v-show则无论初始条件是否成立，都会渲染标签，它仅仅做的只是简单的CSS（display）切换。</p><p>3、 v-if适用于不需要频繁切换元素显示和隐藏的情况<br>    v-show适用于需要频繁切换元素的显示和隐藏的场景。</p><h1 id="3-history路由和hash路由的区别"><a href="#3-history路由和hash路由的区别" class="headerlink" title="3.history路由和hash路由的区别"></a>3.history路由和hash路由的区别</h1><p>首先是样式上的区别<br>刷新是的区别：<br>hash路由会加载到地址栏对应的页面，而history路由一般就404报错了（刷新是网络请求，没有后端准备时会报错）。</p><h1 id="4如何理解vue中的虚拟dom"><a href="#4如何理解vue中的虚拟dom" class="headerlink" title="4如何理解vue中的虚拟dom"></a>4如何理解vue中的虚拟dom</h1><p>是为了解决真实dom带来的性能问题出现的<br>虚拟dom是模拟出来的js对象<br>操作内存中的js对象明显速度会快很多，再将最后的js对象映射到真实dom上</p><h1 id="5谈谈对mixin的理解"><a href="#5谈谈对mixin的理解" class="headerlink" title="5谈谈对mixin的理解"></a>5谈谈对mixin的理解</h1><p>就是定义的一个js的对象，里面有组件里的方法，</p><h1 id="6-vue组件之间的通信"><a href="#6-vue组件之间的通信" class="headerlink" title="6.vue组件之间的通信"></a>6.vue组件之间的通信</h1><p>1.父传子<br>父组件绑定属性值，子组件props接收<br><img src="/2022/07/30/vue/2022-08-01-15-58-37.png"></p><p>2.子传父<br>this.$emit触发自定义事件<br><img src="/2022/07/30/vue/2022-08-01-16-01-56.png"></p><p>3.ref<br>通过实例拿到子组件的数据</p><p>4.创建一个中央事件总线EventBus<br>新建一个bus.js<br>import Vue from ‘vue’<br>const Bus = new Vue()<br>export default Bus</p><p>Vue.prototype.$bus = new Bus();</p><p>组件一<br>this.$bus.$on(‘updateData’, this.getdata);<br>组件二<br>this.$bus.$emit(‘updateData’, {loading: false});</p><p>5.provide返回传递的值<br>inject接收传递过来的值<br>注意他只做祖先通后代的单向传递的一个办法<br>官网不建议在应用中直接使用该办法，理由很直接：他怕你”管不好”</p><p>用法1：祖先组件： provide: {<br>      message: ‘provided by father’<br>    },<br>子孙组件：inject: [ “message” ],</p><p>6.vuex</p><h1 id="7-说说vue的diff算法"><a href="#7-说说vue的diff算法" class="headerlink" title="7.说说vue的diff算法"></a>7.说说vue的diff算法</h1><p>diff算法其实是同层树节点进行比较的高效算法<br>比较的方式是深度优先，同层比较</p><h1 id="8-vue中的过滤器"><a href="#8-vue中的过滤器" class="headerlink" title="8.vue中的过滤器"></a>8.vue中的过滤器</h1><p>我们可以把它理解成一个处理数据的函数，通常用来格式化数据<br>我们可以在当前组件定义filter<br>也可以全局定义<br><img src="/2022/07/30/vue/2022-08-02-08-52-45.png"></p><h1 id="9-vue函数式组件"><a href="#9-vue函数式组件" class="headerlink" title="9.vue函数式组件"></a>9.vue函数式组件</h1><p>函数式组件没有this<br>this通过render的第二个参数context来代替</p><h1 id="10-谈谈vuex"><a href="#10-谈谈vuex" class="headerlink" title="10.谈谈vuex"></a>10.谈谈vuex</h1><p>store 对象中存放的东西是固定的，主要有：state、mutations、actions、getters、modules<br>1.state:主要是用来存放数据的地方<br>例子：const state = {<br>        resturantName:’飞歌餐馆’<br>      };<br>如何获取： this.$store.state.resturantName;</p><p>2.getters<br>state计算派生出来的数据<br>如何获取：this.$store.getters.resturantName</p><p>3.mutation<br>同步修改state里的数据<br>如何触发mutation里面的方法： this.$store.commit(type,payload);</p><p>4.action<br>异步修改state的数据<br>如何触发action方法：this.$store.dispatch(‘setResturantNameByAsync’,{resturantName: ‘啃德鸡2’});<br>action中提交mutation<br>        context.commit(‘setResturantName’,{resturantName: ‘啃德鸡2’});</p><p>vuex常用辅助函数<br> mapState/mapGetters/mapMutations/mapActions</p><h1 id="11-谈谈你对-nexttick理解"><a href="#11-谈谈你对-nexttick理解" class="headerlink" title="11.谈谈你对$nexttick理解"></a>11.谈谈你对$nexttick理解</h1><p>dom更新后的延迟回调<br>一般在你更新完数据后，需要操作你渲染好的dom</p><h1 id="12-vue-router"><a href="#12-vue-router" class="headerlink" title="12.vue-router"></a>12.vue-router</h1><p>1.说到router，就和spa产生了联系。我理解的vue是spa是会关联到router-view这个组件<br>啥是router-view？<br>匹配上的组件会被渲染到router-view这个位置<br>所以vue其实就一个页面就是app.vue<br>关于router还有一个router-link标签,在我认为这就是封装的一个a标签</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>image</title>
      <link href="/2022/07/29/image/"/>
      <url>/2022/07/29/image/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/07/29/image/2022-07-29-21-56-43.png"><br><img src="/2022/07/29/image/2022-07-30-14-44-06.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码演示</title>
      <link href="/2022/05/29/%E4%BB%A3%E7%A0%81%E5%9D%97/%E6%BC%94%E7%A4%BA/"/>
      <url>/2022/05/29/%E4%BB%A3%E7%A0%81%E5%9D%97/%E6%BC%94%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h1><h1 id="图片演示"><a href="#图片演示" class="headerlink" title="图片演示"></a>图片演示</h1><p><img src="/2022/05/29/%E4%BB%A3%E7%A0%81%E5%9D%97/%E6%BC%94%E7%A4%BA/2022-07-29-21-54-48.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line"></span><br><span class="line">let showModal = document.querySelectorAll(&#x27;.show-modal&#x27;);</span><br><span class="line">let close = document.querySelector(&#x27;.close-modal&#x27;);</span><br><span class="line">let modal = document.querySelector(&#x27;.modal&#x27;);</span><br><span class="line">let overlay = document.querySelector(&#x27;.overlay&#x27;);</span><br><span class="line"></span><br><span class="line">const openModal = function () &#123;</span><br><span class="line">  modal.classList.remove(&#x27;hidden&#x27;);</span><br><span class="line">  overlay.classList.remove(&#x27;hidden&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const closeModal = function () &#123;</span><br><span class="line">  overlay.classList.add(&#x27;hidden&#x27;);</span><br><span class="line">  modal.classList.add(&#x27;hidden&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; showModal.length; i++) &#123;</span><br><span class="line">  showModal[i].addEventListener(&#x27;click&#x27;, openModal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close.addEventListener(&#x27;click&#x27;, closeModal);</span><br><span class="line">overlay.addEventListener(&#x27;click&#x27;, closeModal);</span><br><span class="line">document.addEventListener(&#x27;keydown&#x27;, function (e) &#123;</span><br><span class="line">  if (e.key === &#x27;Escape&#x27; &amp;&amp; !modal.classList.contains(&#x27;hidden&#x27;)) &#123;</span><br><span class="line">    closeModal();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -代码 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
